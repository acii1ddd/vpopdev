services:
  master:
    image: postgres:17.0
    container_name: master
    ports:
      - "5433:5432"
    environment:
      POSTGRES_PASSWORD: 123
    volumes:
      - ./pgdata-master:/var/lib/postgresql/data
      - ./scripts/init_master.sh:/docker-entrypoint-initdb.d/init_master.sh
    networks:
      - devpops2
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 5s
      timeout: 3s
      retries: 5
    command: >
        postgres 
          -c wal_level=replica
          -c max_wal_senders=10
          -c max_replication_slots=10
          -c hot_standby=on
    
  slave:
    image: postgres:17.0
    container_name: slave
    environment:
      POSTGRES_PASSWORD: 123
    entrypoint: /docker-entrypoint-initdb.d/init_slave.sh # запускается перед конфигурацией postgres
    ports:
      - "5434:5432"
    volumes:
      - ./pgdata-slave:/var/lib/postgresql/data
      - ./scripts/init_slave.sh:/docker-entrypoint-initdb.d/init_slave.sh
    depends_on:
      master:
        condition: service_healthy
    networks:
      - devpops2

networks:
  devpops2:
    driver: bridge


# /root/.pgpass
# hostname:port:database:username:password
# master:5432:replication:replicator:123
# chmod 0600 ~/.pgpass
# passfile=''/root/.pgpass''

# pg_stat_replication - отображает каждую активную (подключённую) реплику, которая обслуживается своим процессом walsender.
# psql -U postgres -c "SELECT pg_reload_conf();"

# host    replication     replicator      0.0.0.0/0               md5
# pg_basebackup -h master -p 5432 -U replicator -D /data/ -Fp -Xs -R
# docker exec -it postgres-1 bash
# # create a new user
# createuser -U postgresadmin -P -c 5 --replication replicationUser
# exit


# -e POSTGRES_USER=postgresadmin `
# -e POSTGRES_PASSWORD=admin123 `
# -e POSTGRES_DB=postgresdb `
# -e PGDATA="/data" `
# -v ${PWD}/pgdata:/data `
# -v ${PWD}/config:/config `
# -p 5000:5432 `
# хуйня ебанная
# postgres:15.0 -c 'config_file=/config/postgresql.conf'